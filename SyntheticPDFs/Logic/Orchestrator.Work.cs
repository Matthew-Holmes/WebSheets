using SyntheticPDFs.Models;

namespace SyntheticPDFs.Logic
{
    // Put the actual orchestration process in here
    // queuing etc. boilerplate is in the main class file

    using RootName = String;




    public partial class Orchestrator
    {

        internal record SourceMetadata
        {
            internal required SourceType Type { get; init; }
            internal required ISO639_3Code Language { get; init; }

            internal required RootName RootName { get; init; }
        }


        private record TrackedFileWitMetadata
        {
            public required TrackedFile TrackedFile { get; init; }

            public required SourceMetadata SourceMetadata { get; init; }
        }

        private async Task DoWorkAsync()
        {

            // early exit after any git repo change, more maximum granularity of interactions
            // to avoid conflict with other users making changes (since server will always back off and retry)
            // keep track of if had to backoff then reduce the number of files added at a time??

            _logger.LogInformation("Work commencing");

            // prepare model of the repo so can apply business logic
            
            RepoModel repoModel = RepoManager.GetLatestModelOfRepo();

            String texExtNoDot = "tex";

            Dictionary<RootName, HashSet<TrackedFileWitMetadata>> variantInfo = GetVariantInfo(repoModel, texExtNoDot);

            
            // get stale files and remove them

            List<TrackedFileWitMetadata> staleFiles = variantInfo.Values
                .Select(tfwms => GetStaleFiles(tfwms))
                .SelectMany(x => x).ToList();





            // get the files to create, in creation batches, since some depend on each other!




            // decide what to generate (get this in separate file for business logic clarity)
            // create synthetic Tex source
            // pull git again - check nothing has changed
            // commit and push if can
            // backoff if push failure

//            var testTexSource = new TexSourceModel
//            {
//                FileNameNoPathNoExt = "test_document",
//                DirNoFileName = RepoManager.SourceDir + "/" + "test/generated",
//                TexSource =
//@"\documentclass{article}

//\begin{document}

//Hello, world!

//This is a test document generated by the server.

//\end{document}
//"
//            };


            //await RepoManager.CommitAndPushTexSource(testTexSource);


            // Simulate real work
            await Task.Delay(TimeSpan.FromSeconds(10));
        }




        private Dictionary<RootName, HashSet<TrackedFileWitMetadata>> GetVariantInfo(RepoModel repoModel, String extSubset = "tex")
        {
            Dictionary<RootName, HashSet<TrackedFileWitMetadata>> variantInfo = new();

            foreach (TrackedFile tf in repoModel.Contents)
            {
                String ext = tf.FullPath.Split('.').Last();

                if (ext != extSubset) { continue; }

                //                                                                  extension       + "."
                String withoutExt = tf.FullPath.Substring(0, tf.FullPath.Length - (extSubset.Length + 1));

                SourceMetadata sourceMetadata = ParseMetadataFromFilename(withoutExt);

                TrackedFileWitMetadata tsm = new TrackedFileWitMetadata
                {
                    TrackedFile = tf,
                    SourceMetadata = sourceMetadata
                };

                if (variantInfo.ContainsKey(sourceMetadata.RootName))
                {
                    variantInfo[sourceMetadata.RootName].Add(tsm);
                }
                else
                {
                    variantInfo[sourceMetadata.RootName] = new HashSet<TrackedFileWitMetadata> { tsm };
                }
            }

            return variantInfo;
        }


    }
}
